(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const coc_nvim_1 = __webpack_require__(1);
const path_1 = __importDefault(__webpack_require__(2));
const which_1 = __importDefault(__webpack_require__(3));
const util_1 = __webpack_require__(8);
let bufnr;
let { nvim } = coc_nvim_1.workspace;
function activate(context) {
    return __awaiter(this, void 0, void 0, function* () {
        let { subscriptions } = context;
        subscriptions.push(coc_nvim_1.commands.registerCommand('jest.init', initJest));
        subscriptions.push(coc_nvim_1.commands.registerCommand('jest.projectTest', jestProject));
        subscriptions.push(coc_nvim_1.commands.registerCommand('jest.fileTest', jestFile, null, true));
        subscriptions.push(coc_nvim_1.commands.registerCommand('jest.singleTest', jestSingle));
    });
}
exports.activate = activate;
function initJest() {
    return __awaiter(this, void 0, void 0, function* () {
        let { cwd } = coc_nvim_1.workspace;
        coc_nvim_1.workspace.runTerminalCommand('jest --init', cwd);
    });
}
function jestFile(filename) {
    return __awaiter(this, void 0, void 0, function* () {
        let { cwd } = coc_nvim_1.workspace;
        if (filename == '%') {
            let document = yield coc_nvim_1.workspace.document;
            filename = coc_nvim_1.Uri.parse(document.uri).fsPath.toString();
        }
        if (!path_1.default.isAbsolute(filename)) {
            filename = path_1.default.join(cwd, filename);
        }
        let exists = yield util_1.existAsync(filename);
        if (!exists) {
            coc_nvim_1.workspace.showMessage(`${filename} not found`, 'error');
            return;
        }
        let root = yield resolveRoot();
        let cmd = yield resolveJest();
        let configfile = yield resolveConfigFile();
        if (configfile)
            cmd = `${cmd} -c ${path_1.default.relative(root, configfile)}`;
        let opts = yield resolveConfig();
        if (opts)
            cmd = `${cmd} ${opts}`;
        cmd = `${cmd} ${path_1.default.relative(root, filename)}`;
        yield runJestCommand(root, cmd);
    });
}
function jestSingle() {
    return __awaiter(this, void 0, void 0, function* () {
        let document = yield coc_nvim_1.workspace.document;
        if (!document)
            return;
        let u = coc_nvim_1.Uri.parse(document.uri);
        if (u.scheme != 'file')
            return;
        let root = yield resolveRoot();
        let cmd = yield resolveJest();
        let configfile = yield resolveConfigFile();
        if (configfile)
            cmd = `${cmd} -c ${path_1.default.relative(root, configfile)}`;
        let opts = yield resolveConfig();
        if (opts)
            cmd = `${cmd} ${opts}`;
        let lnum = (yield nvim.call('line', '.')) - 1;
        let name;
        while (lnum > 0) {
            let line = document.getline(lnum);
            let ms = line.match(/^\s*(?:it|test)\((["'])(.+)\1/);
            if (ms) {
                name = ms[2];
                break;
            }
            lnum = lnum - 1;
        }
        if (!name)
            return;
        name = name.replace(/'/g, "\\'");
        cmd = `${cmd} ${path_1.default.relative(root, u.fsPath)} -t '${name}'`;
        yield runJestCommand(root, cmd);
    });
}
function jestProject() {
    return __awaiter(this, void 0, void 0, function* () {
        let root = yield resolveRoot();
        let cmd = yield resolveJest();
        let configfile = yield resolveConfigFile();
        if (configfile) {
            cmd = `${cmd} -c ${path_1.default.relative(root, configfile)}`;
        }
        let opts = yield resolveConfig();
        if (opts)
            cmd = `${cmd} ${opts}`;
        yield runJestCommand(root, cmd);
    });
}
function runJestCommand(cwd, cmd) {
    return __awaiter(this, void 0, void 0, function* () {
        if (bufnr) {
            yield nvim.command(`silent! bd! ${bufnr}`);
        }
        let document = yield coc_nvim_1.workspace.document;
        let config = coc_nvim_1.workspace.getConfiguration('jest', document ? document.uri : undefined);
        let position = config.get('terminalPosition');
        bufnr = yield nvim.call('coc#util#open_terminal', {
            autoclose: 0,
            keepfocus: 1,
            position,
            cwd,
            cmd
        });
    });
}
function resolveConfig() {
    return __awaiter(this, void 0, void 0, function* () {
        let args = [];
        let names = ['watch', 'detectLeaks', 'watchman',
            'detectOpenHandles', 'forceExit', 'noStackTrace'];
        let document = yield coc_nvim_1.workspace.document;
        let config = coc_nvim_1.workspace.getConfiguration('jest', document ? document.uri : undefined);
        for (let name of names) {
            if (config.get(name)) {
                args.push(`--${name}`);
            }
        }
        return args.join(' ');
    });
}
function resolveRoot() {
    return __awaiter(this, void 0, void 0, function* () {
        let document = yield coc_nvim_1.workspace.document;
        let cwd;
        if (document) {
            let u = coc_nvim_1.Uri.parse(document.uri);
            cwd = u.scheme == 'file' ? path_1.default.dirname(u.fsPath) : coc_nvim_1.workspace.cwd;
        }
        else {
            cwd = coc_nvim_1.workspace.cwd;
        }
        let dir = yield util_1.findUp(['package.json'], cwd);
        return dir || cwd;
    });
}
function resolveConfigFile() {
    return __awaiter(this, void 0, void 0, function* () {
        let document = yield coc_nvim_1.workspace.document;
        let config = coc_nvim_1.workspace.getConfiguration('jest', document ? document.uri : undefined);
        let filename = config.get('configFileName');
        let u = coc_nvim_1.Uri.parse(document.uri);
        let cwd = u.scheme == 'file' ? path_1.default.dirname(u.fsPath) : coc_nvim_1.workspace.cwd;
        return yield util_1.findUp([filename], cwd);
    });
}
function resolveJest() {
    return __awaiter(this, void 0, void 0, function* () {
        let root = yield resolveRoot();
        if (root) {
            for (let name of ['jest', 'jest.cmd']) {
                let exists = yield util_1.existAsync(path_1.default.join(root, `node_modules/.bin/${name}`));
                if (exists)
                    return `./node_modules/.bin/${name}`;
            }
        }
        try {
            which_1.default.sync('jest');
            return 'jest';
        }
        catch (e) {
            coc_nvim_1.workspace.showMessage('jest executable not found!', 'error');
            return '';
        }
    });
}


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = require("coc.nvim");

/***/ }),
/* 2 */
/***/ (function(module, exports) {

module.exports = require("path");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = which
which.sync = whichSync

var isWindows = process.platform === 'win32' ||
    process.env.OSTYPE === 'cygwin' ||
    process.env.OSTYPE === 'msys'

var path = __webpack_require__(2)
var COLON = isWindows ? ';' : ':'
var isexe = __webpack_require__(4)

function getNotFoundError (cmd) {
  var er = new Error('not found: ' + cmd)
  er.code = 'ENOENT'

  return er
}

function getPathInfo (cmd, opt) {
  var colon = opt.colon || COLON
  var pathEnv = opt.path || process.env.PATH || ''
  var pathExt = ['']

  pathEnv = pathEnv.split(colon)

  var pathExtExe = ''
  if (isWindows) {
    pathEnv.unshift(process.cwd())
    pathExtExe = (opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM')
    pathExt = pathExtExe.split(colon)


    // Always test the cmd itself first.  isexe will check to make sure
    // it's found in the pathExt set.
    if (cmd.indexOf('.') !== -1 && pathExt[0] !== '')
      pathExt.unshift('')
  }

  // If it has a slash, then we don't bother searching the pathenv.
  // just check the file itself, and that's it.
  if (cmd.match(/\//) || isWindows && cmd.match(/\\/))
    pathEnv = ['']

  return {
    env: pathEnv,
    ext: pathExt,
    extExe: pathExtExe
  }
}

function which (cmd, opt, cb) {
  if (typeof opt === 'function') {
    cb = opt
    opt = {}
  }

  var info = getPathInfo(cmd, opt)
  var pathEnv = info.env
  var pathExt = info.ext
  var pathExtExe = info.extExe
  var found = []

  ;(function F (i, l) {
    if (i === l) {
      if (opt.all && found.length)
        return cb(null, found)
      else
        return cb(getNotFoundError(cmd))
    }

    var pathPart = pathEnv[i]
    if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
      pathPart = pathPart.slice(1, -1)

    var p = path.join(pathPart, cmd)
    if (!pathPart && (/^\.[\\\/]/).test(cmd)) {
      p = cmd.slice(0, 2) + p
    }
    ;(function E (ii, ll) {
      if (ii === ll) return F(i + 1, l)
      var ext = pathExt[ii]
      isexe(p + ext, { pathExt: pathExtExe }, function (er, is) {
        if (!er && is) {
          if (opt.all)
            found.push(p + ext)
          else
            return cb(null, p + ext)
        }
        return E(ii + 1, ll)
      })
    })(0, pathExt.length)
  })(0, pathEnv.length)
}

function whichSync (cmd, opt) {
  opt = opt || {}

  var info = getPathInfo(cmd, opt)
  var pathEnv = info.env
  var pathExt = info.ext
  var pathExtExe = info.extExe
  var found = []

  for (var i = 0, l = pathEnv.length; i < l; i ++) {
    var pathPart = pathEnv[i]
    if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
      pathPart = pathPart.slice(1, -1)

    var p = path.join(pathPart, cmd)
    if (!pathPart && /^\.[\\\/]/.test(cmd)) {
      p = cmd.slice(0, 2) + p
    }
    for (var j = 0, ll = pathExt.length; j < ll; j ++) {
      var cur = p + pathExt[j]
      var is
      try {
        is = isexe.sync(cur, { pathExt: pathExtExe })
        if (is) {
          if (opt.all)
            found.push(cur)
          else
            return cur
        }
      } catch (ex) {}
    }
  }

  if (opt.all && found.length)
    return found

  if (opt.nothrow)
    return null

  throw getNotFoundError(cmd)
}


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var fs = __webpack_require__(5)
var core
if (process.platform === 'win32' || global.TESTING_WINDOWS) {
  core = __webpack_require__(6)
} else {
  core = __webpack_require__(7)
}

module.exports = isexe
isexe.sync = sync

function isexe (path, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = {}
  }

  if (!cb) {
    if (typeof Promise !== 'function') {
      throw new TypeError('callback not provided')
    }

    return new Promise(function (resolve, reject) {
      isexe(path, options || {}, function (er, is) {
        if (er) {
          reject(er)
        } else {
          resolve(is)
        }
      })
    })
  }

  core(path, options || {}, function (er, is) {
    // ignore EACCES because that just means we aren't allowed to run it
    if (er) {
      if (er.code === 'EACCES' || options && options.ignoreErrors) {
        er = null
        is = false
      }
    }
    cb(er, is)
  })
}

function sync (path, options) {
  // my kingdom for a filtered catch
  try {
    return core.sync(path, options || {})
  } catch (er) {
    if (options && options.ignoreErrors || er.code === 'EACCES') {
      return false
    } else {
      throw er
    }
  }
}


/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = require("fs");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = isexe
isexe.sync = sync

var fs = __webpack_require__(5)

function checkPathExt (path, options) {
  var pathext = options.pathExt !== undefined ?
    options.pathExt : process.env.PATHEXT

  if (!pathext) {
    return true
  }

  pathext = pathext.split(';')
  if (pathext.indexOf('') !== -1) {
    return true
  }
  for (var i = 0; i < pathext.length; i++) {
    var p = pathext[i].toLowerCase()
    if (p && path.substr(-p.length).toLowerCase() === p) {
      return true
    }
  }
  return false
}

function checkStat (stat, path, options) {
  if (!stat.isSymbolicLink() && !stat.isFile()) {
    return false
  }
  return checkPathExt(path, options)
}

function isexe (path, options, cb) {
  fs.stat(path, function (er, stat) {
    cb(er, er ? false : checkStat(stat, path, options))
  })
}

function sync (path, options) {
  return checkStat(fs.statSync(path), path, options)
}


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = isexe
isexe.sync = sync

var fs = __webpack_require__(5)

function isexe (path, options, cb) {
  fs.stat(path, function (er, stat) {
    cb(er, er ? false : checkStat(stat, options))
  })
}

function sync (path, options) {
  return checkStat(fs.statSync(path), options)
}

function checkStat (stat, options) {
  return stat.isFile() && checkMode(stat, options)
}

function checkMode (stat, options) {
  var mod = stat.mode
  var uid = stat.uid
  var gid = stat.gid

  var myUid = options.uid !== undefined ?
    options.uid : process.getuid && process.getuid()
  var myGid = options.gid !== undefined ?
    options.gid : process.getgid && process.getgid()

  var u = parseInt('100', 8)
  var g = parseInt('010', 8)
  var o = parseInt('001', 8)
  var ug = u | g

  var ret = (mod & o) ||
    (mod & g) && gid === myGid ||
    (mod & u) && uid === myUid ||
    (mod & ug) && myUid === 0

  return ret
}


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(__webpack_require__(2));
const fs_1 = __importDefault(__webpack_require__(5));
const util_1 = __importDefault(__webpack_require__(9));
function findUp(filenames, cwd) {
    return __awaiter(this, void 0, void 0, function* () {
        const { root } = path_1.default.parse(cwd);
        while (cwd != root) {
            for (let file of filenames) {
                let p = path_1.default.join(cwd, file);
                let exists = yield existAsync(p);
                if (exists)
                    return cwd;
                cwd = path_1.default.dirname(cwd);
            }
        }
        return null;
    });
}
exports.findUp = findUp;
function existAsync(filepath) {
    return __awaiter(this, void 0, void 0, function* () {
        let stat = null;
        try {
            stat = yield util_1.default.promisify(fs_1.default.stat)(filepath);
        }
        catch (e) {
            return false;
        }
        return stat && stat.isFile();
    });
}
exports.existAsync = existAsync;


/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = require("util");

/***/ })
/******/ ])));