"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __importDefault(require("./base"));
const connection_1 = __importDefault(require("./connection"));
const request_1 = __importDefault(require("./request"));
class VimTransport extends base_1.default {
    constructor() {
        super();
        this.pending = new Map();
        this.nextRequestId = 0;
        this.attached = false;
        this.notifyMethod = process.env.COC_NVIM == '1' ? 'coc#api#notify' : 'nvim#api#notify';
    }
    attach(writer, reader, client) {
        let connection = this.connection = new connection_1.default(reader, writer);
        this.attached = true;
        this.client = client;
        connection.on('request', (id, obj) => {
            let [method, args] = obj;
            this.emit('request', method, args, this.createResponse(id));
        });
        connection.on('notification', (obj) => {
            let [event, args] = obj;
            this.emit('notification', event.toString(), args);
        });
        connection.on('response', (id, obj) => {
            let req = this.pending.get(id);
            if (req) {
                this.pending.delete(id);
                let err = null;
                let result = null;
                if (!Array.isArray(obj)) {
                    err = obj;
                }
                else {
                    err = obj[0];
                    result = obj[1];
                }
                req.callback(this.client, err, result);
            }
        });
    }
    detach() {
        if (!this.attached)
            return;
        this.attached = false;
        this.connection.dispose();
    }
    /**
     * Send request to vim
     */
    request(method, args, cb) {
        if (!this.attached)
            return cb([0, 'transport disconnected']);
        if (!this.client.hasFunction(method)) {
            // tslint:disable-next-line: no-console
            console.error(`method: ${method} not supported.`);
        }
        this.nextRequestId = this.nextRequestId - 1;
        let req = new request_1.default(this.connection, cb, this.nextRequestId);
        this.pending.set(this.nextRequestId, req);
        req.request(method, args);
    }
    notify(method, args) {
        if (!this.attached)
            return;
        if (!this.client.hasFunction(method)) {
            // tslint:disable-next-line: no-console
            console.error(`method: ${method} not supported.`);
        }
        if (this._paused) {
            this.paused.push([method, args]);
            return;
        }
        this.connection.call(this.notifyMethod, [method.slice(5), args]);
    }
    createResponse(requestId) {
        let called = false;
        let { connection } = this;
        return {
            send: (resp, isError) => {
                if (called || !this.attached)
                    return;
                called = true;
                let err = null;
                if (isError)
                    err = typeof resp === 'string' ? resp : resp.toString();
                connection.response(requestId, [err, isError ? null : resp]);
            }
        };
    }
}
exports.VimTransport = VimTransport;
