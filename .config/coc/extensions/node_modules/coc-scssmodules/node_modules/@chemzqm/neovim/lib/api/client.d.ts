/// <reference types="node" />
import { Neovim } from './Neovim';
import { Buffer } from './Buffer';
import { Window } from './Window';
import { Tabpage } from './Tabpage';
export declare const DETACH_BUFFER: unique symbol;
export declare const ATTACH_BUFFER: unique symbol;
export declare type Callback = (err?: Error | null, res?: any) => void;
export declare class AsyncResponse {
    readonly requestId: number;
    private cb;
    private finished;
    constructor(requestId: number, cb: Callback);
    finish(err?: string | null, res?: any): void;
}
export declare class NeovimClient extends Neovim {
    private _isReady;
    private requestId;
    private transportAttached;
    private responses;
    private _channelId;
    private attachedBuffers;
    private functions;
    private pauseLevel;
    private pauseTimer;
    constructor();
    createBuffer(id: number): Buffer;
    createWindow(id: number): Window;
    createTabpage(id: number): Tabpage;
    /** Attaches msgpack to read/write streams * */
    attach({ reader, writer, }: {
        reader: NodeJS.ReadableStream;
        writer: NodeJS.WritableStream;
    }, requestApi?: boolean): void;
    detach(): void;
    readonly isApiReady: boolean;
    readonly channelId: Promise<number>;
    isAttached(bufnr: number): boolean;
    private handleRequest;
    sendAsyncRequest(method: string, args: any[]): Promise<any>;
    private emitNotification;
    private handleNotification;
    private setupTransport;
    requestApi(): Promise<any[]>;
    private generateApi;
    [ATTACH_BUFFER](buffer: Buffer): void;
    [DETACH_BUFFER](buffer: Buffer): void;
    attachBufferEvent(buffer: Buffer, eventName: string, cb: Function): void;
    /**
     * Returns `true` if buffer should be detached
     */
    detachBufferEvent(buffer: Buffer, eventName: string, cb: Function): void;
    pauseNotification(): void;
    resumeNotification(cancel?: boolean, notify?: boolean): Promise<any>;
    hasFunction(name: string): boolean;
}
