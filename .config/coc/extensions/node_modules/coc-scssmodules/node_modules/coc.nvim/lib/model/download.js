"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const follow_redirects_1 = require("follow-redirects");
const fs_1 = tslib_1.__importDefault(require("fs"));
const mkdirp_1 = tslib_1.__importDefault(require("mkdirp"));
const path_1 = tslib_1.__importDefault(require("path"));
const tar_1 = tslib_1.__importDefault(require("tar"));
const url_1 = require("url");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const fetch_1 = require("./fetch");
/**
 * Download and extract tgz from url
 *
 * @param {string} url
 * @param {DownloadOptions} options contains dest folder and optional onProgress callback
 */
function download(url, options) {
    const rejectUnauthorized = workspace_1.default.getConfiguration('https').get('rejectUnauthorized', true);
    let { dest, onProgress } = options;
    if (!dest || !path_1.default.isAbsolute(dest)) {
        throw new Error(`Expect absolute file path for dest option.`);
    }
    if (!fs_1.default.existsSync(dest))
        mkdirp_1.default.sync(dest);
    let endpoint = url_1.parse(url);
    let mod = url.startsWith('https') ? follow_redirects_1.https : follow_redirects_1.http;
    let agent = fetch_1.getAgent(endpoint);
    let opts = Object.assign({
        method: 'GET',
        hostname: endpoint.hostname,
        port: endpoint.port ? parseInt(endpoint.port, 10) : (endpoint.protocol === 'https:' ? 443 : 80),
        path: endpoint.path,
        protocol: url.startsWith('https') ? 'https:' : 'http:',
        agent,
        rejectUnauthorized,
        headers: {
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64)'
        }
    }, options);
    return new Promise((resolve, reject) => {
        const req = mod.request(opts, (res) => {
            if (res.statusCode != 200) {
                reject(new Error(`Invalid response from ${url}: ${res.statusCode}`));
                return;
            }
            if (onProgress) {
                const len = parseInt(res.headers['content-length'], 10);
                let cur = 0;
                if (!isNaN(len)) {
                    res.on('data', chunk => {
                        cur += chunk.length;
                        onProgress(cur / len);
                    });
                }
            }
            let stream = res.pipe(tar_1.default.x({ strip: 1, C: dest }));
            stream.on('finish', () => {
                setTimeout(resolve, 100);
            });
            stream.on('error', reject);
        });
        req.on('error', reject);
        req.end();
    });
}
exports.default = download;
//# sourceMappingURL=download.js.map