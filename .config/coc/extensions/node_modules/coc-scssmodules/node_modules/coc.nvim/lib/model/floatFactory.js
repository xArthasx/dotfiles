"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const events_1 = tslib_1.__importDefault(require("../events"));
const manager_1 = tslib_1.__importDefault(require("../snippets/manager"));
const util_1 = require("../util");
const object_1 = require("../util/object");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const floatBuffer_1 = tslib_1.__importDefault(require("./floatBuffer"));
const debounce_1 = tslib_1.__importDefault(require("debounce"));
const popup_1 = tslib_1.__importDefault(require("./popup"));
const array_1 = require("../util/array");
const logger = require('../util/logger')('model-float');
// factory class for floating window
class FloatFactory {
    constructor(nvim, env, preferTop = false, maxHeight = 999, maxWidth, autoHide = true) {
        this.nvim = nvim;
        this.env = env;
        this.preferTop = preferTop;
        this.maxHeight = maxHeight;
        this.maxWidth = maxWidth;
        this.autoHide = autoHide;
        this.disposables = [];
        this.alignTop = false;
        this.pumAlignTop = false;
        this.createTs = 0;
        this.cursor = [0, 0];
        this.shown = false;
        if (!workspace_1.default.floatSupported)
            return;
        this.maxWidth = Math.min(maxWidth || 80, this.columns - 10);
        events_1.default.on('BufEnter', bufnr => {
            if (this.buffer && bufnr == this.buffer.id)
                return;
            if (bufnr == this.targetBufnr)
                return;
            this.close();
        }, null, this.disposables);
        events_1.default.on('InsertLeave', bufnr => {
            if (this.buffer && bufnr == this.buffer.id)
                return;
            if (manager_1.default.isActived(bufnr))
                return;
            this.close();
        }, null, this.disposables);
        events_1.default.on('MenuPopupChanged', async (ev, cursorline) => {
            let pumAlignTop = this.pumAlignTop = cursorline > ev.row;
            if (pumAlignTop == this.alignTop) {
                this.close();
            }
        }, null, this.disposables);
        events_1.default.on('CursorMoved', debounce_1.default((bufnr, cursor) => {
            if (Date.now() - this.createTs < 100)
                return;
            this.onCursorMoved(false, bufnr, cursor);
        }, 100), null, this.disposables);
        events_1.default.on('CursorMovedI', this.onCursorMoved.bind(this, true), null, this.disposables);
    }
    onCursorMoved(insertMode, bufnr, cursor) {
        if (!this.window || this.buffer && bufnr == this.buffer.id)
            return;
        if (bufnr == this.targetBufnr && object_1.equals(cursor, this.cursor))
            return;
        if (this.autoHide) {
            this.close();
            return;
        }
        if (!insertMode || bufnr != this.targetBufnr || (this.cursor && cursor[0] != this.cursor[0])) {
            this.close();
            return;
        }
    }
    async checkFloatBuffer() {
        let { floatBuffer, nvim, window } = this;
        if (this.env.textprop) {
            let valid = await this.activated();
            if (!valid)
                window = null;
            if (!window) {
                this.popup = await popup_1.default(nvim, [''], {
                    padding: [0, 1, 0, 1],
                    highlight: 'CocFloating',
                    tab: -1,
                });
                let win = this.window = nvim.createWindow(this.popup.id);
                nvim.pauseNotification();
                win.setVar('float', 1, true);
                win.setOption('linebreak', true, true);
                if (workspace_1.default.isVim && parseInt(workspace_1.default.env.version, 10) >= 8012281) {
                    win.setOption('showbreak', 'NONE', true);
                }
                win.setOption('conceallevel', 2, true);
                await nvim.resumeNotification();
            }
            let buffer = this.nvim.createBuffer(this.popup.bufferId);
            this.floatBuffer = new floatBuffer_1.default(nvim, buffer, nvim.createWindow(this.popup.id));
        }
        else {
            if (floatBuffer) {
                let valid = await floatBuffer.valid;
                if (valid)
                    return;
            }
            let buf = await this.nvim.createNewBuffer(false, true);
            await buf.setOption('buftype', 'nofile');
            await buf.setOption('bufhidden', 'hide');
            this.floatBuffer = new floatBuffer_1.default(this.nvim, buf);
        }
    }
    get columns() {
        return this.env.columns;
    }
    get lines() {
        return this.env.lines - this.env.cmdheight - 1;
    }
    async getBoundings(docs, offsetX = 0) {
        let { nvim, preferTop } = this;
        let { columns, lines } = this;
        let alignTop = false;
        let [row, col] = await nvim.call('coc#util#win_position');
        let maxWidth = this.maxWidth;
        let height = this.floatBuffer.getHeight(docs, maxWidth);
        height = Math.min(height, this.maxHeight);
        if (!preferTop) {
            if (lines - row < height && row > height) {
                alignTop = true;
            }
        }
        else {
            if (row >= height || row >= lines - row) {
                alignTop = true;
            }
        }
        if (alignTop)
            docs.reverse();
        await this.floatBuffer.setDocuments(docs, maxWidth);
        let { width } = this.floatBuffer;
        // Ensure the floating window isn't tiny if the cursor is on the right:
        // increase the offset to accommodate some minimum width.
        // If we have offsetX, precise positioning is intended, force exact width.
        let minWidth = offsetX ? width : Math.min(width, 50, maxWidth);
        offsetX = Math.min(col - 1, offsetX);
        if (col - offsetX + minWidth > columns) {
            offsetX = col - offsetX + minWidth - columns;
        }
        this.alignTop = alignTop;
        return {
            height: alignTop ? Math.max(1, Math.min(row, height)) : Math.max(1, Math.min(height, (lines - row))),
            width: Math.min(columns, width),
            row: alignTop ? -height : 1,
            col: offsetX == 0 ? 0 : -offsetX,
            relative: 'cursor'
        };
    }
    async create(docs, allowSelection = false, offsetX = 0) {
        if (!workspace_1.default.floatSupported) {
            logger.error('Floating window & textprop not supported!');
            return;
        }
        let shown = await this.createPopup(docs, allowSelection, offsetX);
        if (!shown)
            this.close(false);
    }
    async createPopup(docs, allowSelection = false, offsetX = 0) {
        if (this.tokenSource) {
            this.tokenSource.cancel();
        }
        if (docs.length == 0)
            return false;
        this.createTs = Date.now();
        this.targetBufnr = workspace_1.default.bufnr;
        let tokenSource = this.tokenSource = new vscode_languageserver_protocol_1.CancellationTokenSource();
        let token = tokenSource.token;
        await this.checkFloatBuffer();
        let config = await this.getBoundings(docs, offsetX);
        let [mode, line, col, visible] = await this.nvim.eval('[mode(),line("."),col("."),pumvisible()]');
        this.cursor = [line, col];
        if (visible && this.alignTop == this.pumAlignTop)
            return false;
        if (!config || token.isCancellationRequested)
            return false;
        if (!this.checkMode(mode, allowSelection))
            return false;
        let { nvim, alignTop } = this;
        if (mode == 's')
            await nvim.call('feedkeys', ['\x1b', 'in']);
        // helps to fix undo issue, don't know why.
        if (workspace_1.default.isNvim && mode.startsWith('i'))
            await nvim.eval('feedkeys("\\<C-g>u", "n")');
        let reuse = false;
        if (workspace_1.default.isNvim) {
            reuse = this.window && await this.window.valid;
            if (!reuse)
                this.window = await nvim.openFloatWindow(this.buffer, false, config);
        }
        if (token.isCancellationRequested)
            return false;
        nvim.pauseNotification();
        if (workspace_1.default.isNvim) {
            if (!reuse) {
                nvim.command(`noa call win_gotoid(${this.window.id})`, true);
                this.window.setVar('float', 1, true);
                nvim.command(`setl nospell nolist wrap linebreak foldcolumn=1 showbreak=`, true);
                nvim.command(`setl nonumber norelativenumber nocursorline nocursorcolumn colorcolumn=`, true);
                nvim.command(`setl signcolumn=no conceallevel=2 concealcursor=n`, true);
                nvim.command(`setl winhl=Normal:CocFloating,NormalNC:CocFloating,FoldColumn:CocFloating`, true);
                nvim.call('coc#util#do_autocmd', ['CocOpenFloat'], true);
            }
            else {
                this.window.setConfig(config, true);
                nvim.command(`noa call win_gotoid(${this.window.id})`, true);
            }
            this.floatBuffer.setLines();
            nvim.command(`normal! ${alignTop ? 'G' : 'gg'}0`, true);
            nvim.command('noa wincmd p', true);
        }
        else {
            let filetypes = array_1.distinct(docs.map(d => d.filetype));
            if (filetypes.length == 1) {
                this.popup.setFiletype(filetypes[0]);
            }
            this.popup.move({
                line: cursorPostion(config.row),
                col: cursorPostion(config.col),
                minwidth: config.width - 2,
                minheight: config.height,
                maxwidth: config.width - 2,
                maxheight: this.maxHeight,
                firstline: alignTop ? -1 : 1
            });
            this.floatBuffer.setLines();
            nvim.command('redraw', true);
        }
        let [, err] = await nvim.resumeNotification();
        if (err) {
            workspace_1.default.showMessage(`Error on ${err[0]}: ${err[1]} - ${err[2]}`, 'error');
            return false;
        }
        if (mode == 's')
            await manager_1.default.selectCurrentPlaceholder(false);
        return true;
    }
    checkMode(mode, allowSelection) {
        if (mode == 's' && allowSelection) {
            return true;
        }
        return ['i', 'n', 'ic'].indexOf(mode) != -1;
    }
    /**
     * Close float window
     */
    close(cancel = true) {
        if (cancel && this.tokenSource) {
            if (this.tokenSource) {
                this.tokenSource.cancel();
                this.tokenSource = null;
            }
        }
        let { window, popup } = this;
        this.shown = false;
        if (this.env.textprop) {
            if (popup)
                popup.dispose();
        }
        else if (window) {
            window.close(true, true);
        }
    }
    dispose() {
        if (this.tokenSource) {
            this.tokenSource.cancel();
        }
        util_1.disposeAll(this.disposables);
    }
    get buffer() {
        return this.floatBuffer ? this.floatBuffer.buffer : null;
    }
    async activated() {
        if (this.env.textprop) {
            if (!this.popup)
                return false;
            return await this.popup.visible();
        }
        if (!this.window)
            return false;
        let valid = await this.window.valid;
        return valid;
    }
}
exports.default = FloatFactory;
function cursorPostion(n) {
    if (n == 0)
        return 'cursor';
    if (n < 0)
        return `cursor${n}`;
    return `cursor+${n}`;
}
//# sourceMappingURL=floatFactory.js.map