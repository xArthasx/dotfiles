"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const vscode_languageserver_protocol_1 = require("vscode-languageserver-protocol");
const callSequence_1 = tslib_1.__importDefault(require("../util/callSequence"));
const object_1 = require("../util/object");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const util_1 = require("./util");
const logger = require('../util/logger')('diagnostic-buffer');
const severityNames = ['CocError', 'CocWarning', 'CocInfo', 'CocHint'];
// maintains sign and highlightId
class DiagnosticBuffer {
    constructor(bufnr, config) {
        this.config = config;
        this.signIds = new Set();
        this.sequence = null;
        this._onDidRefresh = new vscode_languageserver_protocol_1.Emitter();
        this.matchIds = new Set();
        this.diagnostics = [];
        this.onDidRefresh = this._onDidRefresh.event;
        this.bufnr = bufnr;
        this.srdId = workspace_1.default.createNameSpace('coc-diagnostic');
        let timer = null;
        let time = Date.now();
        this.refresh = (diagnostics) => {
            time = Date.now();
            if (timer)
                clearTimeout(timer);
            timer = setTimeout(async () => {
                let current = time;
                if (this.sequence) {
                    await this.sequence.cancel();
                }
                // staled
                if (current != time || !this.document)
                    return;
                diagnostics.forEach(o => {
                    o.range = this.fixRange(o.range);
                });
                this._refresh(diagnostics);
            }, 30);
        };
    }
    _refresh(diagnostics) {
        if (object_1.equals(this.diagnostics, diagnostics))
            return;
        let { nvim } = this;
        let sequence = this.sequence = new callSequence_1.default();
        let winid;
        let bufnr;
        sequence.addFunction(async () => {
            let arr = await nvim.eval(`[coc#util#valid_state(), bufwinid(${this.bufnr}), bufnr("%")]`);
            if (arr[0] == 0 || !this.document)
                return true;
            winid = arr[1];
            bufnr = arr[2];
        });
        sequence.addFunction(async () => {
            nvim.pauseNotification();
            this.setDiagnosticInfo(bufnr, diagnostics);
            this.addSigns(diagnostics);
            this.setLocationlist(diagnostics, winid);
            this.addHighlight(diagnostics, winid);
            this.addDiagnosticVText(diagnostics);
            let res = await this.nvim.resumeNotification();
            if (Array.isArray(res) && res[1])
                logger.error('Diagnostic error:', res[1]);
        });
        sequence.start().then(async (canceled) => {
            if (!canceled) {
                this.diagnostics = diagnostics;
                this._onDidRefresh.fire(void 0);
            }
        }, e => {
            logger.error(e);
        });
    }
    setLocationlist(diagnostics, winid) {
        if (!this.config.locationlist)
            return;
        let { nvim, bufnr } = this;
        // not shown
        if (winid == -1)
            return;
        let items = [];
        for (let diagnostic of diagnostics) {
            let item = util_1.getLocationListItem(diagnostic.source, bufnr, diagnostic);
            items.push(item);
        }
        nvim.call('setloclist', [winid, [], ' ', { title: 'Diagnostics of coc', items }], true);
    }
    clearSigns() {
        let { nvim, signIds, bufnr } = this;
        if (signIds.size > 0) {
            nvim.call('coc#util#unplace_signs', [bufnr, Array.from(signIds)], true);
            signIds.clear();
        }
    }
    async checkSigns() {
        let { nvim, bufnr, signIds } = this;
        try {
            let content = await this.nvim.call('execute', [`sign place buffer=${bufnr}`]);
            let lines = content.split('\n');
            let ids = [];
            for (let line of lines) {
                let ms = line.match(/^\s*line=\d+\s+id=(\d+)\s+name=(\w+)/);
                if (!ms)
                    continue;
                let [, id, name] = ms;
                if (!signIds.has(Number(id)) && severityNames.indexOf(name) != -1) {
                    ids.push(id);
                }
            }
            await nvim.call('coc#util#unplace_signs', [bufnr, ids]);
        }
        catch (e) {
            // noop
        }
    }
    addSigns(diagnostics) {
        if (!this.config.enableSign && !this.config.enableHighlightLineNumber)
            return;
        this.clearSigns();
        let { nvim, bufnr, signIds } = this;
        let signId = this.config.signOffset;
        signIds.clear();
        let lines = new Set();
        for (let diagnostic of diagnostics) {
            let { range, severity } = diagnostic;
            let line = range.start.line;
            if (lines.has(line))
                continue;
            lines.add(line);
            let name = util_1.getNameFromSeverity(severity);
            nvim.command(`sign place ${signId} line=${line + 1} name=${name} buffer=${bufnr}`, true);
            signIds.add(signId);
            signId = signId + 1;
        }
    }
    setDiagnosticInfo(bufnr, diagnostics) {
        let lnums = [0, 0, 0, 0];
        let info = { error: 0, warning: 0, information: 0, hint: 0, lnums };
        for (let diagnostic of diagnostics) {
            switch (diagnostic.severity) {
                case vscode_languageserver_protocol_1.DiagnosticSeverity.Warning:
                    info.warning = info.warning + 1;
                    lnums[1] = lnums[1] || diagnostic.range.start.line + 1;
                    break;
                case vscode_languageserver_protocol_1.DiagnosticSeverity.Information:
                    info.information = info.information + 1;
                    lnums[2] = lnums[2] || diagnostic.range.start.line + 1;
                    break;
                case vscode_languageserver_protocol_1.DiagnosticSeverity.Hint:
                    info.hint = info.hint + 1;
                    lnums[3] = lnums[3] || diagnostic.range.start.line + 1;
                    break;
                default:
                    lnums[0] = lnums[0] || diagnostic.range.start.line + 1;
                    info.error = info.error + 1;
            }
        }
        this.nvim.call('coc#util#set_buf_var', [this.bufnr, 'coc_diagnostic_info', info], true);
        if (bufnr == this.bufnr) {
            this.nvim.call('coc#util#do_autocmd', ['CocDiagnosticChange'], true);
        }
    }
    addDiagnosticVText(diagnostics) {
        let { bufnr, nvim } = this;
        if (!this.config.virtualText)
            return;
        if (!nvim.hasFunction('nvim_buf_set_virtual_text'))
            return;
        let buffer = this.nvim.createBuffer(bufnr);
        let lines = new Set();
        let srcId = this.config.virtualTextSrcId;
        let prefix = this.config.virtualTextPrefix;
        buffer.clearNamespace(srcId);
        for (let diagnostic of diagnostics) {
            let { line } = diagnostic.range.start;
            if (lines.has(line))
                continue;
            lines.add(line);
            let highlight = util_1.getNameFromSeverity(diagnostic.severity) + 'VirtualText';
            let msg = diagnostic.message.split(/\n/)
                .map((l) => l.trim())
                .filter((l) => l.length > 0)
                .slice(0, this.config.virtualTextLines)
                .join(this.config.virtualTextLineSeparator);
            buffer.setVirtualText(srcId, line, [[prefix + msg, highlight]], {}).logError();
        }
    }
    clearHighlight() {
        let { matchIds } = this;
        if (!this.document)
            return;
        this.document.clearMatchIds(matchIds);
        this.matchIds.clear();
    }
    addHighlight(diagnostics, winid) {
        this.clearHighlight();
        if (diagnostics.length == 0)
            return;
        if (winid == -1 && workspace_1.default.isVim && !workspace_1.default.env.textprop)
            return;
        const highlights = new Map();
        for (let diagnostic of diagnostics) {
            let { range, severity } = diagnostic;
            let hlGroup = util_1.getNameFromSeverity(severity) + 'Highlight';
            let ranges = highlights.get(hlGroup) || [];
            ranges.push(range);
            highlights.set(hlGroup, ranges);
        }
        for (let [hlGroup, ranges] of highlights.entries()) {
            let matchIds = this.document.highlightRanges(ranges, hlGroup, this.srdId);
            for (let id of matchIds)
                this.matchIds.add(id);
        }
    }
    // fix range out of total characters
    fixRange(range) {
        let { start, end } = range;
        if (start.line != end.line)
            return range;
        let line = this.document.getline(start.line);
        if (!line)
            return range;
        if (start.character < line.length)
            return range;
        return vscode_languageserver_protocol_1.Range.create(start.line, line.length - 1, start.line, line.length);
    }
    /**
     * Used on buffer unload
     *
     * @public
     * @returns {Promise<void>}
     */
    async clear() {
        if (this.sequence)
            this.sequence.cancel().logError();
        let { nvim } = this;
        nvim.pauseNotification();
        this.clearHighlight();
        this.clearSigns();
        if (this.config.virtualText
            && nvim.hasFunction('nvim_buf_set_virtual_text')
            && this.document) {
            this.document.buffer.clearNamespace(this.config.virtualTextSrcId);
        }
        this.setDiagnosticInfo(workspace_1.default.bufnr, []);
        await nvim.resumeNotification(false, true);
    }
    dispose() {
        if (this.sequence) {
            this.sequence.cancel().logError();
        }
        this._onDidRefresh.dispose();
    }
    get document() {
        if (!this.bufnr)
            return null;
        return workspace_1.default.getDocument(this.bufnr);
    }
    get uri() {
        if (!this.document)
            return null;
        return this.document.uri;
    }
    get nvim() {
        return workspace_1.default.nvim;
    }
}
exports.DiagnosticBuffer = DiagnosticBuffer;
//# sourceMappingURL=buffer.js.map