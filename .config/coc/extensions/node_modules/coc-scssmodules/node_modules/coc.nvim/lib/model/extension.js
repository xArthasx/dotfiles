"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const child_process_1 = require("child_process");
const fs_1 = tslib_1.__importDefault(require("fs"));
const mkdirp_1 = tslib_1.__importDefault(require("mkdirp"));
const mv_1 = tslib_1.__importDefault(require("mv"));
const os_1 = tslib_1.__importDefault(require("os"));
const path_1 = tslib_1.__importDefault(require("path"));
const rc_1 = tslib_1.__importDefault(require("rc"));
const rimraf_1 = tslib_1.__importDefault(require("rimraf"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const url_1 = tslib_1.__importDefault(require("url"));
const util_1 = require("util");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const download_1 = tslib_1.__importDefault(require("./download"));
const fetch_1 = tslib_1.__importDefault(require("./fetch"));
const logger = require('../util/logger')('model-extension');
function registryUrl(scope = 'coc.nvim') {
    const result = rc_1.default('npm', { registry: 'https://registry.npmjs.org/' });
    const registry = result[`${scope}:registry`] || result.config_registry || result.registry;
    return registry.endsWith('/') ? registry : registry + '/';
}
class ExtensionManager {
    constructor(root) {
        this.root = root;
        this.checked = false;
    }
    checkFolder() {
        if (this.checked)
            return;
        this.checked = true;
        let { root } = this;
        mkdirp_1.default.sync(root);
        mkdirp_1.default.sync(path_1.default.join(root, 'node_modules/.cache'));
    }
    async getInfo(ref) {
        if (ref.startsWith('https:'))
            return await this.getInfoFromUri(ref);
        let name;
        let version;
        if (ref.indexOf('@') > 0) {
            [name, version] = ref.split('@', 2);
        }
        else {
            name = ref;
        }
        let res = await fetch_1.default(url_1.default.resolve(registryUrl(), name));
        if (!version)
            version = res['dist-tags']['latest'];
        let obj = res['versions'][version];
        if (!obj)
            throw new Error(`${ref} not exists.`);
        let requiredVersion = obj['engines'] && obj['engines']['coc'];
        if (!requiredVersion) {
            throw new Error(`${ref} is not valid coc extension, "engines" field with coc property required.`);
        }
        return {
            'dist.tarball': obj['dist']['tarball'],
            'engines.coc': requiredVersion,
            version: obj['version'],
            name: res.name
        };
    }
    async removeFolder(folder) {
        if (fs_1.default.existsSync(folder)) {
            let stat = await util_1.promisify(fs_1.default.lstat)(folder);
            if (stat.isSymbolicLink()) {
                await util_1.promisify(fs_1.default.unlink)(folder);
            }
            else {
                await util_1.promisify(rimraf_1.default)(folder, { glob: false });
            }
        }
    }
    async _install(npm, def, info, onMessage) {
        let tmpFolder = await util_1.promisify(fs_1.default.mkdtemp)(path_1.default.join(os_1.default.tmpdir(), `${info.name}-`));
        let url = info['dist.tarball'];
        onMessage(`Downloading from ${url}`);
        await download_1.default(url, { dest: tmpFolder });
        let content = await util_1.promisify(fs_1.default.readFile)(path_1.default.join(tmpFolder, 'package.json'), 'utf8');
        let { dependencies } = JSON.parse(content);
        if (dependencies && Object.keys(dependencies).length) {
            onMessage(`Installing dependencies.`);
            let p = new Promise((resolve, reject) => {
                let args = ['install', '--ignore-scripts', '--no-lockfile', '--no-bin-links', '--production'];
                if (info['dist.tarball'] && info['dist.tarball'].indexOf('github.com') !== -1) {
                    args = ['install'];
                }
                const child = child_process_1.spawn(npm, args, { cwd: tmpFolder });
                child.stderr.setEncoding('utf8');
                child.on('error', reject);
                let err = '';
                child.stderr.on('data', data => {
                    err += data;
                });
                child.on('exit', code => {
                    if (code) {
                        // tslint:disable-next-line: no-console
                        console.error(`${npm} install exited with ${code}, messages:\n${err}`);
                    }
                    resolve();
                });
            });
            await p;
        }
        let jsonFile = path_1.default.join(this.root, 'package.json');
        let obj = JSON.parse(fs_1.default.readFileSync(jsonFile, 'utf8'));
        obj.dependencies = obj.dependencies || {};
        if (/^https?:/.test(def)) {
            obj.dependencies[info.name] = def;
        }
        else {
            obj.dependencies[info.name] = '>=' + info.version;
        }
        const sortedObj = { dependencies: {} };
        Object.keys(obj.dependencies).sort().forEach(k => {
            sortedObj.dependencies[k] = obj.dependencies[k];
        });
        fs_1.default.writeFileSync(jsonFile, JSON.stringify(sortedObj, null, 2), { encoding: 'utf8' });
        onMessage(`Moving to new folder.`);
        let folder = path_1.default.join(this.root, 'node_modules', info.name);
        await this.removeFolder(folder);
        await util_1.promisify(mv_1.default)(tmpFolder, folder, { mkdirp: true });
    }
    async install(npm, def) {
        this.checkFolder();
        logger.info(`Using npm from: ${npm}`);
        logger.info(`Loading info of ${def}.`);
        let info = await this.getInfo(def);
        let { name } = info;
        let required = info['engines.coc'] ? info['engines.coc'].replace(/^\^/, '>=') : '';
        if (required && !semver_1.default.satisfies(workspace_1.default.version, required)) {
            throw new Error(`${name} ${info.version} requires coc.nvim >= ${required}, please update coc.nvim.`);
        }
        await this._install(npm, def, info, msg => {
            logger.info(msg);
        });
        workspace_1.default.showMessage(`Installed extension: ${name}`, 'more');
        logger.info(`Installed extension: ${name}`);
        return name;
    }
    async update(npm, name, uri) {
        this.checkFolder();
        let folder = path_1.default.join(this.root, 'node_modules', name);
        let stat = await util_1.promisify(fs_1.default.lstat)(folder);
        if (stat.isSymbolicLink()) {
            logger.info(`skipped update of ${name}`);
            return false;
        }
        let version;
        if (fs_1.default.existsSync(path_1.default.join(folder, 'package.json'))) {
            let content = await util_1.promisify(fs_1.default.readFile)(path_1.default.join(folder, 'package.json'), 'utf8');
            version = JSON.parse(content).version;
        }
        logger.info(`Loading info of ${name}.`);
        let info = await this.getInfo(uri ? uri : name);
        if (version && info.version && semver_1.default.gte(version, info.version)) {
            logger.info(`Extension ${name} is up to date.`);
            return false;
        }
        let required = info['engines.coc'] ? info['engines.coc'].replace(/^\^/, '>=') : '';
        if (required && !semver_1.default.satisfies(workspace_1.default.version, required)) {
            throw new Error(`${name} ${info.version} requires coc.nvim >= ${required}, please update coc.nvim.`);
        }
        await this._install(npm, uri ? uri : name, info, msg => { logger.info(msg); });
        workspace_1.default.showMessage(`Updated extension: ${name} to ${info.version}`, 'more');
        logger.info(`Update extension: ${name}`);
        return true;
    }
    async getInfoFromUri(uri) {
        if (uri.indexOf('github.com') == -1)
            return;
        uri = uri.replace(/\/$/, '');
        let fileUrl = uri.replace('github.com', 'raw.githubusercontent.com') + '/master/package.json';
        let content = await fetch_1.default(fileUrl);
        let obj = typeof content == 'string' ? JSON.parse(content) : content;
        return {
            'dist.tarball': `${uri}/archive/master.tar.gz`,
            'engines.coc': obj['engines'] ? obj['engines']['coc'] : undefined,
            name: obj.name,
            version: obj.version
        };
    }
}
exports.default = ExtensionManager;
//# sourceMappingURL=extension.js.map