"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const follow_redirects_1 = require("follow-redirects");
const tunnel_1 = tslib_1.__importDefault(require("tunnel"));
const url_1 = require("url");
const zlib_1 = tslib_1.__importDefault(require("zlib"));
const is_1 = require("../util/is");
const workspace_1 = tslib_1.__importDefault(require("../workspace"));
const logger = require('../util/logger')('model-fetch');
function getAgent(endpoint) {
    let key = endpoint.protocol.startsWith('https') ? 'HTTPS_PROXY' : 'HTTP_PROXY';
    let env = process.env[key] || process.env[key.toLowerCase()];
    if (env) {
        let noProxy = process.env.NO_PROXY || process.env.no_proxy;
        if (noProxy === '*') {
            env = null;
        }
        else if (noProxy) {
            // canonicalize the hostname, so that 'oogle.com' won't match 'google.com'
            const hostname = endpoint.hostname.replace(/^\.*/, '.').toLowerCase();
            const port = endpoint.port || endpoint.protocol.startsWith('https') ? '443' : '80';
            const noProxyList = noProxy.split(',');
            for (let i = 0, len = noProxyList.length; i < len; i++) {
                let noProxyItem = noProxyList[i].trim().toLowerCase();
                // no_proxy can be granular at the port level, which complicates things a bit.
                if (noProxyItem.indexOf(':') > -1) {
                    let noProxyItemParts = noProxyItem.split(':', 2);
                    let noProxyHost = noProxyItemParts[0].replace(/^\.*/, '.');
                    let noProxyPort = noProxyItemParts[1];
                    if (port === noProxyPort && hostname.endsWith(noProxyHost)) {
                        env = null;
                        break;
                    }
                }
                else {
                    noProxyItem = noProxyItem.replace(/^\.*/, '.');
                    if (hostname.endsWith(noProxyItem)) {
                        env = null;
                        break;
                    }
                }
            }
        }
    }
    let proxy = workspace_1.default.getConfiguration('http').get('proxy', '');
    if (!proxy && env) {
        proxy = env;
    }
    if (proxy) {
        proxy = proxy.replace(/^https?:\/\//, '').replace(/\/$/, '');
        let auth = proxy.includes('@') ? proxy.split('@', 2)[0] : '';
        let parts = auth.length ? proxy.slice(auth.length + 1).split(':') : proxy.split(':');
        logger.info(`Using proxy from: ${proxy}`);
        if (parts.length > 1) {
            let agent = tunnel_1.default.httpsOverHttp({
                proxy: {
                    headers: {},
                    host: parts[0],
                    port: parseInt(parts[1], 10),
                    proxyAuth: auth
                }
            });
            return agent;
        }
    }
}
exports.getAgent = getAgent;
/**
 * Fetch text from server
 */
function fetch(url, data, options = {}) {
    logger.info('fetch:', url);
    let rejectUnauthorized = workspace_1.default.getConfiguration('https').get('rejectUnauthorized', true);
    let mod = url.startsWith('https') ? follow_redirects_1.https : follow_redirects_1.http;
    let endpoint = url_1.parse(url);
    let agent = getAgent(endpoint);
    let opts = Object.assign({
        method: 'GET',
        hostname: endpoint.hostname,
        port: endpoint.port ? parseInt(endpoint.port, 10) : (endpoint.protocol === 'https:' ? 443 : 80),
        path: endpoint.path,
        protocol: url.startsWith('https') ? 'https:' : 'http:',
        agent,
        rejectUnauthorized,
        headers: {
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64)',
            'Accept-Encoding': 'gzip'
        }
    }, options);
    if (data && is_1.objectLiteral(data)) {
        opts.headers['Content-Type'] = 'application/json';
    }
    if (data && !opts.method) {
        opts.method = 'POST';
    }
    return new Promise((resolve, reject) => {
        // tslint:disable-next-line: only-arrow-functions
        try {
            const req = mod.request(opts, res => {
                let readable = res;
                if (res.statusCode != 200) {
                    reject(new Error(`Invalid response from ${url}: ${res.statusCode}`));
                    return;
                }
                let chunks = [];
                let contentType = res.headers['content-type'];
                let contentEncoding = res.headers['content-encoding'];
                let ms = contentType.match(/charset=(\S+)/);
                let encoding = ms ? ms[1] : 'utf8';
                if (contentEncoding == 'gzip') {
                    const unzip = zlib_1.default.createGunzip();
                    readable = res.pipe(unzip);
                }
                readable.on('data', chunk => {
                    chunks.push(chunk);
                });
                readable.on('end', () => {
                    let buf = Buffer.concat(chunks);
                    let rawData = buf.toString(encoding);
                    if (/^application\/json/.test(contentType)) {
                        try {
                            const parsedData = JSON.parse(rawData);
                            resolve(parsedData);
                        }
                        catch (e) {
                            reject(`Parse error: ${e}`);
                        }
                    }
                    else {
                        resolve(rawData);
                    }
                });
            });
            req.on('error', reject);
            if (data) {
                if (typeof data == 'string') {
                    req.write(data);
                }
                else {
                    req.write(JSON.stringify(data));
                }
            }
            req.end();
        }
        catch (e) {
            logger.error(e);
            reject(e);
        }
    });
}
exports.default = fetch;
//# sourceMappingURL=fetch.js.map